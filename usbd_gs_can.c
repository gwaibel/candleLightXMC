/**
 * @file usbd_winusb.c
 * @date 2015-10-08
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * USBD_WINUSB v4.0.10 - The USBD_WINUSB is the Windows winusb.sys driver interface to the XMC4000 family of controllers.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the           
 * following conditions are met:   
 *                                                                              
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following   
 *   disclaimer.                        
 * 
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the    
 *   following disclaimer in the documentation and/or other materials provided with the distribution.     
 *                         
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written permission. 
 *                                             
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,  
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,  
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR        
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,      
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE   
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    
 *                                                                              
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes       
 * with Infineon Technologies AG (dave@infineon.com).        
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version.      
 * 2015-03-18:
 *     - Guidelines updated.
 * 2015-04-23:
 *     - Updated the review comments from AEs.
 * 2015-06-20:
 *     - Updated the file header.
 *     
 * @endcond 
 *
 */


/***********************************************************************************************************************
 * HEADER FILES                                                                                                      
 **********************************************************************************************************************/
#include "usbd_gs_can.h"
#include "can.h"

/**********************************************************************************************************************
 * MACROS                                                                                                            
 **********************************************************************************************************************/
#define USBD_GS_CAN_VENDOR_CODE      0x20

#define USBD_IDX_LANGID_STR          0x00
#define USBD_IDX_MFC_STR             0x01
#define USBD_IDX_PRODUCT_STR         0x02
#define USBD_IDX_SERIAL_STR          0x03

#define USBD_VID                     0x1d50
#define USBD_PID_FS                  0x606f
#define USB_MAX_EP0_SIZE             64

#define USBD_TXRX_EPSIZE             32U
#define GSCAN_CONTROL_EPNUM          0U
#define GSCAN_IN_EPNUM               1U
#define GSCAN_OUT_EPNUM              2U

#define DFU_INTERFACE_NUM            1U

#define NUM_CAN_CHANNEL              2U

#define MIN(a,b) (((a)<(b))?(a):(b))

/**
\brief  USB configuration descriptor
*/
typedef struct
{
   USB_Descriptor_Configuration_Header_t    t_Config;                     /**<Configuration descriptor header*/
   USB_Descriptor_Interface_t               t_Interface;                  /**<interface data structure*/
   USB_Descriptor_Endpoint_t                t_Data_in_endpoint;           /**<IN endpoint data structure*/
   USB_Descriptor_Endpoint_t                t_Data_out_endpoint;          /**<OUT endpoint data structure*/
} T_USB_Descriptor_Configuration;


typedef struct
{
   struct
   {
      USB_Endpoint_Table_t in_endpoint; /**< IN Endpoint Configuration */
      USB_Endpoint_Table_t out_endpoint; /**< OUT Endpoint Configuration */
   } config;
} USBD_GS_CAN_Info_t;


typedef struct {
   //__IO uint32_t TxState;
   //USBD_SetupReqTypedef last_setup_request;
   struct gs_host_config host_config;
   queue_t *q_frame_pool;
   queue_t *q_from_host;
   //struct gs_host_frame *from_host_buf;
   uint8_t channels[NUM_CAN_CHANNEL];
   //uint32_t out_requests;
   //uint32_t out_requests_fail;
   //uint32_t out_requests_no_buf;
   led_data_t *leds;
   //bool dfu_detach_requested;
   bool timestamps_enabled;
   uint32_t sof_timestamp_us;
} USBD_GS_CAN_HandleTypeDef __attribute__ ((aligned (4)));


/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/**
 * Buffer to hold transmit and receive data
 **/
static uint8_t mau8_RxBuffer[USBD_TXRX_EPSIZE];
static uint8_t mau8_TxBuffer[USBD_TXRX_EPSIZE];

/**
 * USB device maximum number of endpoints
 * Will get update according to USBD app UI.
 **/
uint8_t usbd_max_eps = 0U;


static USBD_GS_CAN_HandleTypeDef mt_CanDevice;


static led_seq_step_t led_identify_seq[] =
{
   { .state = 0x01, .time_in_10ms = 10 },
   { .state = 0x02, .time_in_10ms = 10 },
   { .state = 0x00, .time_in_10ms = 0 }
};



// device info

static const struct gs_device_config mt_USBD_GS_CAN_dconf =
{
   0, // reserved 1
   0, // reserved 2
   0, // reserved 3
   0, // interface count (0=1, 1=2..)
   2, // software version
   1  // hardware version
};

//GW TODO: adapt constants:
// bit timing constraints
static const struct gs_device_bt_const mt_USBD_GS_CAN_btconst =
{
   GS_CAN_FEATURE_LISTEN_ONLY  // supported features
   | GS_CAN_FEATURE_LOOP_BACK
   | GS_CAN_FEATURE_HW_TIMESTAMP
   | GS_CAN_FEATURE_IDENTIFY
   | GS_CAN_FEATURE_USER_ID,
   CAN_MODULE_FREQUENCY, // can timing base clock
   1, // tseg1 min
   16, // tseg1 max
   1, // tseg2 min
   8, // tseg2 max
   4, // sjw max
   1, // brp min
   512, //1024, //brp_max
   1, // brp increment;
};


/** Device descriptor structure. This descriptor, located in FLASH memory,
 * describes the overall device characteristics, including the supported USB
 * version, control end point size and the number of device configurations.
 * The descriptor is read out by the USB host when the enumeration process
 * begins.
 */
static const USB_Descriptor_Device_t mt_DeviceDescriptor =
{
   .Header                 = {.Size = sizeof(USB_Descriptor_Device_t),
                                 .Type = DTYPE_Device},

   .USBSpecification       = 0x0200,
   .Class                  = USB_CSCP_NoDeviceClass,
   .SubClass               = USB_CSCP_NoDeviceSubclass,
   .Protocol               = USB_CSCP_NoDeviceProtocol,
   .Endpoint0Size          = USB_MAX_EP0_SIZE,
   .VendorID               = USBD_VID,
   .ProductID              = USBD_PID_FS,
   .ReleaseNumber          = 0x0000,
   .ManufacturerStrIndex   = USBD_IDX_MFC_STR,
   .ProductStrIndex        = USBD_IDX_PRODUCT_STR,
   .SerialNumStrIndex      = USBD_IDX_SERIAL_STR,

   .NumberOfConfigurations = 1
};


/*Endpoint info data structure*/
USBD_GS_CAN_Info_t gs_can_endpoint_info = {
      .config = {
            .in_endpoint = {
                  .Address = (ENDPOINT_DIR_IN | GSCAN_IN_EPNUM),
                  .Size = USBD_TXRX_EPSIZE,
                  .Type = EP_TYPE_BULK
            },
            .out_endpoint = {
                  .Address = (ENDPOINT_DIR_OUT | GSCAN_OUT_EPNUM),
                  .Size = USBD_TXRX_EPSIZE,
                  .Type = EP_TYPE_BULK
            }
      }
};


/** Configuration descriptor structure. This descriptor, located in FLASH
 * memory, describes the usage of the device in one of its supported
 * configurations, including information about any device interfaces and
 * end points. The descriptor is read out by the USB host during the enumeration
 * process when selecting a configuration so that the host may correctly
 * communicate with the USB device.
 */
static const T_USB_Descriptor_Configuration mt_ConfigurationDescriptor =
{
   .t_Config =
      {
         .Header                 = { .Size = sizeof(USB_Descriptor_Configuration_Header_t),
                                     .Type = DTYPE_Configuration },
         .TotalConfigurationSize = sizeof(T_USB_Descriptor_Configuration),
         .TotalInterfaces        = 1, // TODO: 2?
         .ConfigurationNumber    = 1,
         .ConfigurationStrIndex  = NO_DESCRIPTOR,
         .ConfigAttributes       = (USB_CONFIG_ATTR_RESERVED),
         .MaxPowerConsumption    = USB_CONFIG_POWER_MA(150)
      },
   .t_Interface =
      {
         .Header                 = { .Size = sizeof(USB_Descriptor_Interface_t),
                                     .Type = DTYPE_Interface },
         .InterfaceNumber        = 0,
         .AlternateSetting       = 0,
         .TotalEndpoints         = 2,  // TODO 2 richtig?
         .Class                  = USB_CSCP_VendorSpecificClass,
         .SubClass               = USB_CSCP_NoDeviceSubclass,
         .Protocol               = USB_CSCP_NoDeviceProtocol,
         .InterfaceStrIndex      = NO_DESCRIPTOR
      },
   .t_Data_in_endpoint =
      {
         .Header                 = { .Size = sizeof(USB_Descriptor_Endpoint_t),
                                     .Type = DTYPE_Endpoint },
         .EndpointAddress        = (ENDPOINT_DIR_IN | GSCAN_IN_EPNUM),
         .Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC |
                                          ENDPOINT_USAGE_DATA),
         .EndpointSize           = USBD_TXRX_EPSIZE,
         .PollingIntervalMS      = 0x00
      },
   .t_Data_out_endpoint =
      {
         .Header                 =
                  {.Size = sizeof(USB_Descriptor_Endpoint_t),
                        .Type = DTYPE_Endpoint},
         .EndpointAddress        = (ENDPOINT_DIR_OUT | GSCAN_OUT_EPNUM),
         .Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC |
                                          ENDPOINT_USAGE_DATA),
         .EndpointSize           = USBD_TXRX_EPSIZE,
         .PollingIntervalMS      = 0x00
      }
};

/** Language descriptor structure. This descriptor, located in FLASH memory,
 * is returned when the host requests the string descriptor with index
 * 0 (the first index). It is actually an array of 16-bit integers, which
 * indicate via the language ID table available at USB.org what languages the
 * device supports for its string descriptors.
 */
static const USB_Descriptor_String_t mt_LanguageString =
{
   .Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
   .UnicodeString          = {LANGUAGE_ID_ENG}
};
/** Manufacturer descriptor string. This is a Unicode string containing the
 * manufacturer's details in human readable form, and is read out upon request
 * by the host when the appropriate string ID is requested, listed in the Device
 *  Descriptor.
 */
static const USB_Descriptor_String_t mt_ManufacturerString =
{
   .Header                 = {.Size = USB_STRING_LEN(2),
                              .Type = DTYPE_String},
   .UnicodeString          = { 'g', 'w' }
};
/** Product descriptor string. This is a Unicode string containing the product's
 *  details in human readable form, and is read out upon request by the host
 *  when the appropriate string ID is requested, listed in the Device
 *  Descriptor.
 */
static const USB_Descriptor_String_t mt_ProductString =
{
   .Header                 = {.Size = USB_STRING_LEN(14),
                              .Type = DTYPE_String},
   .UnicodeString          = { 'C', 'a', 'n', 'd', 'l', 'e', 'L', 'i', 'g', 'h', 't', 'X', 'M', 'C' }

};
/** Serial descriptor string. This is a Unicode string containing the product's
 *  details in human readable form, and is read out upon request by the host
 *  when the appropriate string ID is requested, listed in the Device
 *  Descriptor.
 */
static  const USB_Descriptor_String_t mt_SerialString =
{
   .Header                 = {.Size = USB_STRING_LEN(12),
                              .Type = DTYPE_String},
   .UnicodeString          = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2' }
};


/*  Microsoft Compatible ID Feature Descriptor  */

static uint8_t mau8_USBD_MS_COMP_ID_FEATURE_DESC[] =
{
   0x40, 0x00, 0x00, 0x00, /* length */
   0x00, 0x01,             /* version 1.0 */
   0x04, 0x00,             /* descr index (0x0004) */
   0x02,                   /* number of sections */
   0x00, 0x00, 0x00, 0x00, /* reserved */
   0x00, 0x00, 0x00,
   0x00,                   /* interface number */
   0x01,                   /* reserved */
   0x57, 0x49, 0x4E, 0x55, /* compatible ID ("WINUSB\0\0") */
   0x53, 0x42, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, /* sub-compatible ID */
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, /* reserved */
   0x00, 0x00,
   0x01,                   /* interface number */
   0x01,                   /* reserved */
   0x57, 0x49, 0x4E, 0x55, /* compatible ID ("WINUSB\0\0") */
   0x53, 0x42, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, /* sub-compatible ID */
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, /* reserved */
   0x00, 0x00
};

/* Microsoft Extended Properties Feature Descriptor */
static uint8_t mau8_USBD_MS_EXT_PROP_FEATURE_DESC[] =
{
   0x92, 0x00, 0x00, 0x00, /* length */
   0x00, 0x01,          /* version 1.0 */
   0x05, 0x00,             /* descr index (0x0005) */
   0x01, 0x00,             /* number of sections */
   0x88, 0x00, 0x00, 0x00, /* property section size */
   0x07, 0x00, 0x00, 0x00, /* property data type 7: Unicode REG_MULTI_SZ */
   0x2a, 0x00,          /* property name length */
   0x44, 0x00, 0x65, 0x00, /* property name "DeviceInterfaceGUIDs" */
   0x76, 0x00, 0x69, 0x00,
   0x63, 0x00, 0x65, 0x00,
   0x49, 0x00, 0x6e, 0x00,
   0x74, 0x00, 0x65, 0x00,
   0x72, 0x00, 0x66, 0x00,
   0x61, 0x00, 0x63, 0x00,
   0x65, 0x00, 0x47, 0x00,
   0x55, 0x00, 0x49, 0x00,
   0x44, 0x00, 0x73, 0x00,
   0x00, 0x00,
   0x50, 0x00, 0x00, 0x00, /* property data length */
   0x7b, 0x00, 0x63, 0x00, /* property name: "{c15b4308-04d3-11e6-b3ea-6057189e6443}\0\0" */
   0x31, 0x00, 0x35, 0x00,
   0x62, 0x00, 0x34, 0x00,
   0x33, 0x00, 0x30, 0x00,
   0x38, 0x00, 0x2d, 0x00,
   0x30, 0x00, 0x34, 0x00,
   0x64, 0x00, 0x33, 0x00,
   0x2d, 0x00, 0x31, 0x00,
   0x31, 0x00, 0x65, 0x00,
   0x36, 0x00, 0x2d, 0x00,
   0x62, 0x00, 0x33, 0x00,
   0x65, 0x00, 0x61, 0x00,
   0x2d, 0x00, 0x36, 0x00,
   0x30, 0x00, 0x35, 0x00,
   0x37, 0x00, 0x31, 0x00,
   0x38, 0x00, 0x39, 0x00,
   0x65, 0x00, 0x36, 0x00,
   0x34, 0x00, 0x34, 0x00,
   0x33, 0x00, 0x7d, 0x00,
   0x00, 0x00, 0x00, 0x00
};


static int m_Connect(void);
//static int m_Disconnect(void);
static void m_EventReset(void);
static uint16_t m_EventGetDescriptor(const uint16_t w_value,
                               const uint16_t w_index,
                               const void** const descriptor_address);

/***********************************************************************************************************************
 * GLOBAL DATA
 **********************************************************************************************************************/

/* Connect device to USB host */
static int m_Connect(void)
{
  return (USBD_Connect() == USBD_STATUS_SUCCESS) ? 0 : -1;
}

/* Disconnect device from USB host */
/*
static int m_Disconnect(void)
{
   return (USBD_Disconnect() == USBD_STATUS_SUCCESS) ? 0 : -1;
}
*/

/* Event handler for the USB reset event. */
static void m_EventReset(void)
{
   USBD_GS_CAN_Status_t t_GsCanStatus;

   /*For self powered devices, reinitialize USB*/
   if (device.IsConfigured)
   {
      device.IsConfigured = 0U;
// GW TODO:
      t_GsCanStatus = USBD_GS_CAN_Init(NULL, NULL, NULL);
      if (t_GsCanStatus != USBD_GS_CAN_STATUS_SUCCESS)
      {
         m_Connect();
      }
   }
}



/** This function is called by the library when in device mode, and must be
 * overridden (see library "USB Descriptors" documentation) by the application
 * code so that the address and size of a requested descriptor can be given
 *  to the USB library. When the device receives a Get Descriptor request on
 *  the control end point, this function is called so that the descriptor
 *  details can be passed back and the appropriate descriptor sent back to the
 *  USB host.
 */
static uint16_t m_EventGetDescriptor(const uint16_t w_value,
                                     const uint16_t w_index,
                                     const void** const descriptor_address)
{
   const uint8_t  descriptor_type   = (w_value >> 8);
   const uint8_t  descriptor_number = (w_value & 0xFF);

   const void* address = NULL;
   uint16_t    size    = NO_DESCRIPTOR;

   switch (descriptor_type)
   {
      case DTYPE_Device:
         address = &mt_DeviceDescriptor;
         size    = sizeof(USB_Descriptor_Device_t);
         break;
      case DTYPE_Configuration:
         address = &mt_ConfigurationDescriptor;
         size    = sizeof(T_USB_Descriptor_Configuration);
         break;
      case DTYPE_String:
         switch (descriptor_number)
         {
            case USBD_IDX_LANGID_STR:
               address = &mt_LanguageString;
               size    = mt_LanguageString.Header.Size;
               break;
            case USBD_IDX_MFC_STR:
               address = &mt_ManufacturerString;
               size    = mt_ManufacturerString.Header.Size;
               break;
            case USBD_IDX_PRODUCT_STR:
               address = &mt_ProductString;
               size    = mt_ProductString.Header.Size;
               break;
            case USBD_IDX_SERIAL_STR:
               address = &mt_SerialString;
               size    = mt_SerialString.Header.Size;
               break;
         }
         break;
   }

   (void)w_index;
   *descriptor_address = address;
   return size;
}



/*The API to configure the USB end points*/
static uint8_t m_ConfigureEndpoints(USBD_GS_CAN_Info_t* const gs_can_interface)
{
  uint8_t status;
  /* configure in endpoint */
  status = (uint8_t)Endpoint_ConfigureEndpointTable(&gs_can_interface->config.in_endpoint, 1U);

  if (1U == status)
  {
    /* configure out endpoint */
    status = (uint8_t)Endpoint_ConfigureEndpointTable(&gs_can_interface->config.out_endpoint, 1U);
  }

  return status;
}


/*
 * USB device configuration changed event callback.
 * Here we reconfigure the USB end points.
 * */
static void m_EventConfigChanged(void)
{
   uint32_t i;
   uint8_t status;
   /* Clear configured flag */
   for (i = ((uint32_t)usbd_max_eps - 1); i > 0U; i--)
   {
     device.Endpoints[((uint32_t)usbd_max_eps - i)].IsConfigured = 0U;
   }
   USBD_SetEndpointBuffer(gs_can_endpoint_info.config.in_endpoint.Address, mau8_TxBuffer,(uint16_t)USBD_TXRX_EPSIZE);
   USBD_SetEndpointBuffer(gs_can_endpoint_info.config.out_endpoint.Address, mau8_RxBuffer,(uint16_t)USBD_TXRX_EPSIZE);
   if (m_ConfigureEndpoints(&gs_can_endpoint_info))
   {
     /* Unconfigure all enabled but not used endpoints */
     for (i = ((uint32_t)usbd_max_eps - 1); i > 0U; i--)
     {
       USBD_Endpoint_t *ep = &device.Endpoints[(((uint32_t)usbd_max_eps - i))];
       if ((0U == ep->IsConfigured) && (1U == ep->IsEnabled))
       {
         status = (uint8_t)device.Driver->EndpointUnconfigure(ep->Number);
         (void)status;
       }
     }
     device.IsConfigured = 1U;
     USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
   }
}


static void m_DFU_Request(volatile USB_Request_Header_t* pt_Request)
{

}

static void m_Config_Request(volatile USB_Request_Header_t* pt_Request)
{
   //USBD_GS_CAN_HandleTypeDef *hcan = (USBD_GS_CAN_HandleTypeDef*) pdev->pClassData;
   //uint32_t d32;
   struct gs_device_bittiming t_Timing;
   struct gs_device_mode t_Mode;
   uint8_t u8_Channel;
   uint32_t u32_Param;

//TODO   Endpoint_SelectEndpoint(ENDPOINT_DIR_IN | GSCAN_CONTROL_EPNUM);

   switch (pt_Request->bRequest)
   {
      case GS_USB_BREQ_HOST_FORMAT:
         // TODO process host data (expect 0x0000beef in byte_order)
         Endpoint_Read_Control_Stream_LE(&mt_CanDevice.host_config, sizeof(mt_CanDevice.host_config));
         Endpoint_ClearSETUP();
         break;
      case GS_USB_BREQ_IDENTIFY:
         Endpoint_Read_Control_Stream_LE(&u32_Param, sizeof(u32_Param));
         Endpoint_ClearSETUP();
         if (u32_Param) {
            led_run_sequence(mt_CanDevice.leds, led_identify_seq, -1);
         } else {
            u8_Channel = mt_CanDevice.channels[pt_Request->wValue]; // TODO verify wValue input data (implement getChannelData() ?)
            led_set_mode(mt_CanDevice.leds, can_is_enabled(u8_Channel) ? led_mode_normal : led_mode_off);
         }
         break;
      case GS_USB_BREQ_SET_USER_ID:
         Endpoint_Read_Control_Stream_LE(&u32_Param, sizeof(u32_Param));
         //Endpoint_ClearSETUP();
         /* DFU not supported
         Endpoint_ClearIN();
         if (flash_set_user_id(req->wValue, u32_Param)) {
            flash_flush();
         }
         */
         break;
      case GS_USB_BREQ_MODE:
         if (pt_Request->wValue < NUM_CAN_CHANNEL)
         {
            Endpoint_Read_Control_Stream_LE(&t_Mode, sizeof(struct gs_device_mode));
            Endpoint_ClearSETUP();
            u8_Channel = mt_CanDevice.channels[pt_Request->wValue];
            if (t_Mode.mode == GS_CAN_MODE_RESET)
            {
               can_disable(u8_Channel);
               led_set_mode(mt_CanDevice.leds, led_mode_off);
            }
            else if (t_Mode.mode == GS_CAN_MODE_START)
            {
               mt_CanDevice.timestamps_enabled = (t_Mode.flags & GS_CAN_MODE_HW_TIMESTAMP) != 0;
               can_enable(u8_Channel,
                          (t_Mode.flags & GS_CAN_MODE_LOOP_BACK) != 0,
                          (t_Mode.flags & GS_CAN_MODE_LISTEN_ONLY) != 0,
                          (t_Mode.flags & GS_CAN_MODE_ONE_SHOT) != 0
                  // triple sampling not supported on bxCAN
                  );
               led_set_mode(mt_CanDevice.leds, led_mode_normal);
            }
         }
         break;
      case GS_USB_BREQ_BITTIMING:
         Endpoint_Read_Control_Stream_LE(&t_Timing, sizeof(struct gs_device_bittiming));
         Endpoint_ClearSETUP();
         if (pt_Request->wValue < NUM_CAN_CHANNEL)
         {
            can_set_bittiming(mt_CanDevice.channels[pt_Request->wValue],
                              t_Timing.brp,
                              t_Timing.prop_seg + t_Timing.phase_seg1,
                              t_Timing.phase_seg2,
                              t_Timing.sjw
            );
         }
         break;
      case GS_USB_BREQ_DEVICE_CONFIG:
         Endpoint_ClearSETUP();
         Endpoint_Write_Control_Stream_LE(&mt_USBD_GS_CAN_dconf, pt_Request->wLength);
         break;
      case GS_USB_BREQ_BT_CONST:
         Endpoint_ClearSETUP();
         Endpoint_Write_Control_Stream_LE(&mt_USBD_GS_CAN_btconst, pt_Request->wLength);
         break;
      case GS_USB_BREQ_TIMESTAMP:
         Endpoint_ClearSETUP();
         Endpoint_Write_Control_Stream_LE(&mt_CanDevice.sof_timestamp_us, sizeof(mt_CanDevice.sof_timestamp_us));
         break;
      case GS_USB_BREQ_GET_USER_ID:
         /* DFU not supported
         if (pt_Request->wValue < NUM_CAN_CHANNEL)
         {
            //d32 = flash_get_user_id(pt_Request->wValue);
            //memcpy(hcan->ep0_buf, &d32, sizeof(d32));
            //USBD_CtlSendData(pdev, hcan->ep0_buf, sizeof(d32));
         }
         else
         {
            USBD_CtlError(pdev, req);
         }
         */
         u32_Param = 0U;
         Endpoint_ClearSETUP();
         Endpoint_Write_Control_Stream_LE(&u32_Param, sizeof(uint32_t));
         break;
      default:
         Endpoint_ClearOUT();
         //USBD_CtlError(pdev, req);
         break;
   }
}


static void m_VendorRequest(volatile USB_Request_Header_t* pt_Request)
{
   uint8_t u8_ReqRcpt = pt_Request->bmRequestType & CONTROL_REQTYPE_RECIPIENT;
   uint8_t u8_ReqType = pt_Request->bmRequestType & CONTROL_REQTYPE_TYPE;

   if ((u8_ReqType == REQTYPE_CLASS) &&
       (u8_ReqRcpt == REQREC_INTERFACE) &&
       (pt_Request->wIndex == DFU_INTERFACE_NUM))
   {
      m_DFU_Request(pt_Request);
   }
   else
   {
      m_Config_Request(pt_Request);
   }
}


uint8_t m_CustomDeviceRequest(volatile USB_Request_Header_t* pt_Request)
{
   uint16_t len = 0;
   uint8_t *pbuf;

   if (pt_Request->bRequest == USBD_GS_CAN_VENDOR_CODE) {
      switch (pt_Request->wIndex)
      {
         case 0x0004:
            pbuf = mau8_USBD_MS_COMP_ID_FEATURE_DESC;
            len = sizeof(mau8_USBD_MS_COMP_ID_FEATURE_DESC);
            Endpoint_ClearSETUP();
            Endpoint_Write_Control_Stream_LE(pbuf, MIN(len, pt_Request->wLength));
            return 1U;
         case 0x0005:
            if (pt_Request->wValue==0)
            { // only return our GUID for interface #0
               pbuf = mau8_USBD_MS_EXT_PROP_FEATURE_DESC;
               len = sizeof(mau8_USBD_MS_EXT_PROP_FEATURE_DESC);
               Endpoint_ClearSETUP();
               Endpoint_Write_Control_Stream_LE(pbuf, MIN(len, pt_Request->wLength));
               return 1U;
            }
            break;
      }
   }

   return 0U;
}

uint8_t  m_CustomInterfaceRequest(volatile USB_Request_Header_t* pt_Request)
{
   return m_CustomDeviceRequest(pt_Request);
}


/*The USB device control request callback.
 * This can be used by the customers to handle the class/vendor specific
 * USB requests
 * */
static void m_EventControlRequest(void)
{
   static uint8_t u8_Ifalt = 0;
   uint8_t u8_ReqRcpt = USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT;
   uint8_t u8_ReqType = USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_TYPE;
   uint8_t u8_ReqCmd = USB_ControlRequest.bRequest;
   uint8_t u8_ReqHandled;

   if (u8_ReqRcpt == REQREC_DEVICE)
   {  // device request
      u8_ReqHandled = m_CustomDeviceRequest(&USB_ControlRequest);
   }
   else if (u8_ReqRcpt == REQREC_INTERFACE)
   {  // interface request
      u8_ReqHandled = m_CustomInterfaceRequest(&USB_ControlRequest);
   }

   if (u8_ReqHandled == 0U)
   {
//TODO      if (USB_ControlRequest.bRequest)
      {
         switch (u8_ReqType)
         {
            case REQTYPE_VENDOR:
            case REQTYPE_CLASS:
               m_VendorRequest(&USB_ControlRequest);
               break;
            case REQTYPE_STANDARD:
               switch (u8_ReqCmd)
               {
                  case REQ_GetInterface:
                     Endpoint_ClearSETUP();
                     Endpoint_Write_Control_Stream_LE(&u8_Ifalt, 1U);
                     break;
                  case REQ_SetInterface:
                  default:
                     break;
               }
               break;
            default:
               break;
         }
      }
   }
}



/* Initialize the USB device */
USBD_GS_CAN_Status_t USBD_GS_CAN_Init(queue_t *q_frame_pool, queue_t *q_from_host, led_data_t *leds)
{
   USBD_STATUS_t t_UsbdStatus;
   USBD_GS_CAN_Status_t t_GsCanStatus = USBD_GS_CAN_STATUS_SUCCESS;

   XMC_ASSERT("USBD_GS_CAN_Init: gs_can_handle not valid", (gs_can_handle != NULL));

   mt_CanDevice.q_frame_pool = q_frame_pool;
   mt_CanDevice.q_from_host = q_from_host;
   mt_CanDevice.leds = leds;

   /*Register the required USB events*/
   // TODO
   USBD_handle->event_cb->set_address = NULL;
   USBD_handle->event_cb->config_changed = &m_EventConfigChanged;
   USBD_handle->event_cb->connect = NULL;
   USBD_handle->event_cb->control_request = &m_EventControlRequest;
   USBD_handle->event_cb->disconnect = NULL;
   USBD_handle->event_cb->get_descriptor = &m_EventGetDescriptor;
   USBD_handle->event_cb->suspend = NULL;
   USBD_handle->event_cb->wakeup = NULL;
   USBD_handle->event_cb->start_of_frame = NULL;
   USBD_handle->event_cb->reset = &m_EventReset;

   usbd_max_eps = (uint8_t)USBD_handle->usb_init.usbd_max_num_eps;

   t_UsbdStatus = USBD_Init(USBD_handle);
   if (t_UsbdStatus != USBD_STATUS_SUCCESS)
   {
      t_GsCanStatus = USBD_GS_CAN_STATUS_FAILURE;
   }
   m_Connect();

   return t_GsCanStatus;
}


uint8_t USBD_GS_CAN_GetProtocolVersion(void)
{
   if (mt_CanDevice.timestamps_enabled)
   {
      return 2;
   }
   else
   {
      return 1;
   }
}


uint8_t USBD_GS_CAN_TxReady(void)
{
   uint8_t u8_Ret = 0;

   // check if device is not configured
   if (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured)
   {
     // Selecet in endpoint
      Endpoint_SelectEndpoint(gs_can_endpoint_info.config.in_endpoint.Address);

     // check if endpoint is ready
     if (Endpoint_IsINReady())
     {
       u8_Ret = 1;
     }
   }

   return u8_Ret;
//   return (mt_CanDevice.TxState == 0);
}


uint8_t USBD_GS_CAN_Transmit(uint8_t *buf, uint16_t len)
{
   uint8_t u8_Ret = USBD_BUSY;

   /* leave if device is not configured */
   if (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured)
   {
      // ????
      //ep_addr |= (uint8_t)ENDPOINT_DIR_MASK; ???
      //Endpoint_SelectEndpoint(ENDPOINT_DIR_IN | GSCAN_IN_EPNUM);
      Endpoint_SelectEndpoint(gs_can_endpoint_info.config.in_endpoint.Address);
      if (Endpoint_IsINReady())
      {
         /* write data to endpoint and then flush the data */
         if (Endpoint_Write_Stream_LE(buf, len, NULL) == (uint8_t)ENDPOINT_RWSTREAM_NoError )
         {
            Endpoint_ClearIN();
            u8_Ret = USBD_OK;
         }
      }
   }

   return u8_Ret;
}


uint8_t USBD_GS_CAN_SendFrame(struct gs_host_frame *frame)
{
   size_t len = sizeof(struct gs_host_frame);
   if (!mt_CanDevice.timestamps_enabled)
   {
      len -= 4;
   }

   return USBD_GS_CAN_Transmit((uint8_t*)frame, len);
}

uint8_t USBD_GS_CAN_IsEnumDone(void)
{
   return (uint32_t)(USBD_IsEnumDone() && (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured));
}


void USBD_GS_CAN_Receive(void)
{
   uint8_t u8_NoFifo = 0;

   /* leave if device is not configured */
   if (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured)
   {
      // ????
      //ep_addr |= (uint8_t)ENDPOINT_DIR_MASK; ???
      //Endpoint_SelectEndpoint(ENDPOINT_DIR_IN | GSCAN_IN_EPNUM);
      Endpoint_SelectEndpoint(gs_can_endpoint_info.config.out_endpoint.Address);
      if (Endpoint_IsOUTReceived())
      {
         while (Endpoint_BytesInEndpoint() >= sizeof(struct gs_host_frame))
         {
            struct gs_host_frame *frame = queue_pop_front(mt_CanDevice.q_frame_pool);
            if (frame != 0)
            {
               if (Endpoint_Read_Stream_LE(frame, sizeof(struct gs_host_frame), NULL) == (uint8_t)ENDPOINT_RWSTREAM_NoError)
               {
                  queue_push_back(mt_CanDevice.q_from_host, frame);
               }
            }
            else
            {
               // Try again later
               u8_NoFifo = 1;
               break;
            }
         }

         if (u8_NoFifo == 0)
         {
            Endpoint_ClearOUT();
         }
      }
   }
}
